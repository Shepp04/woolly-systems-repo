# Teleporters System

A complete teleportation system with queue management, countdown timers, party support, and reserved server creation for Roblox games.

## Overview

The Teleporters system provides:
- **Public teleporters** with configurable player limits
- **Party teleporters** with custom party sizes and friends-only mode
- **Queue management** with visual feedback
- **Countdown timers** before teleportation
- **Reserved server creation** for each teleport group
- **Leave queue functionality** via client GUI
- **Party reservation system** with timeout protection
- **Cooldown system** to prevent spam
- **Automatic cleanup** on player death or disconnect

## System Structure

```
Teleporters/
├── server/
│   ├── classes/
│   │   └── Teleporter.luau           # Individual teleporter class
│   └── services/
│       └── TeleporterService.luau    # Service to manage all teleporters
└── README.md                         # This file
```

## Quick Start

### 1. Create Teleporter Models in Workspace

Create a folder named `Teleporters` in `workspace` and add models for each teleporter:

```
Workspace/
└── Teleporters/
    ├── MainTeleporter (Model)
    │   ├── Trigger (BasePart)           # Required: Touch detection
    │   ├── PlayerSpawn (BasePart)       # Optional: Spawn location
    │   └── TeleportGui (BillboardGui)   # Optional: Status display
    │       ├── Message (TextLabel)
    │       └── Countdown (TextLabel)
    └── PartyTeleporter (Model)
        ├── Trigger (BasePart)
        ├── PlayerSpawn (BasePart)
        └── TeleportGui (BillboardGui)
            ├── Message (TextLabel)
            └── Countdown (TextLabel)
```

**Required Components:**
- `Trigger` (BasePart): The part players touch to join the queue
- `Model`: The parent model containing all components

**Optional Components:**
- `PlayerSpawn` (BasePart): Where players spawn when joining queue (defaults to model pivot)
- `TeleportGui` (BillboardGui): Custom status display (auto-generated if missing)
- `Message` (TextLabel): Shows queue status
- `Countdown` (TextLabel): Shows countdown timer

### 2. Configure TeleporterService

Edit `TeleporterService.luau` to create your teleporters:

```lua
function TeleporterService:Start()
    if not self._inited or self._started then return end
    self._started = true

    local teleportersFolder = workspace:WaitForChild("Teleporters")
    local teleporterObjects = {}
    
    for _, v in teleportersFolder:GetChildren() do
        if not v:IsA("Model") then continue end

        local object
        if v.Name == "MainTeleporter" then
            object = TeleporterClass.new(_deps, {
                teleportPlaceId = 124240592130904,
                model = v,
                countdown = 25,
                teleporterType = "Public",
                minPlayers = 2,
                maxPlayers = 25
            })
        end
        
        if v.Name == "PartyTeleporter" then
            object = TeleporterClass.new(_deps, {
                teleportPlaceId = 124240592130904,
                model = v,
                countdown = 10,
                teleporterType = "Party",
                minPlayers = 2,
                maxPlayers = 8
            })
        end
        
        if object then
            object:Init()
            table.insert(teleporterObjects, object)
        end
    end
end
```

### 3. Setup Required UI Assets

Place these GUI assets in `ReplicatedStorage.Shared.Assets.UI`:

1. **LeaveTeleportQueueGui** (ScreenGui)
   - Button to leave the teleporter queue
   - Connected via RemoteEvent "LeaveTeleportQueue"

2. **ReserveTeleportPartyGui** (ScreenGui)
   - Party size selection interface
   - Friends-only toggle
   - Attributes: `MinPartySize`, `MaxPartySize`
   - Connected via RemoteEvent "CreateTeleportParty"

3. **TeleportFadeGui** (Optional)
   - Fade-to-black effect during teleportation
   - Auto-generated by system if not provided

## Configuration Options

### Teleporter Options

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `model` | `Model` | **Required** | The workspace model for this teleporter |
| `teleportPlaceId` | `number` | `0` | Target place ID to teleport to |
| `minPlayers` | `number` | `1` | Minimum players needed to start countdown |
| `maxPlayers` | `number` | `16` | Maximum players allowed in queue |
| `countdown` | `number` | `30` | Countdown duration in seconds |
| `instantTeleportOnFull` | `boolean` | `true` | Teleport immediately when full |
| `teleporterType` | `"Public" \| "Party"` | `"Public"` | Type of teleporter |

### Teleporter Types

#### Public Teleporter
Standard teleporter that accepts any player up to max capacity.

```lua
{
    teleportPlaceId = 123456789,
    model = workspace.Teleporters.MainTeleporter,
    countdown = 30,
    teleporterType = "Public",
    minPlayers = 4,
    maxPlayers = 16,
    instantTeleportOnFull = true
}
```

**Behavior:**
- Any player can join by touching the trigger
- Countdown starts when `minPlayers` is reached
- Teleports when countdown ends or `maxPlayers` is reached
- Shows "Players: X/Y" on GUI

#### Party Teleporter
Allows first player to reserve the teleporter and set party size.

```lua
{
    teleportPlaceId = 123456789,
    model = workspace.Teleporters.PartyTeleporter,
    countdown = 10,
    teleporterType = "Party",
    minPlayers = 2,
    maxPlayers = 8,
    instantTeleportOnFull = true
}
```

**Behavior:**
1. First player locks the teleporter
2. Gets 10-second window to set party size (2-8 players)
3. Can enable friends-only mode
4. Other players can join after party is created
5. If friends-only, validates friendship before allowing entry
6. Countdown starts when `minPlayers` is reached
7. Teleports when countdown ends or party is full

## API Reference

### Teleporter Class

#### Constructor

##### `Teleporter.new(deps, opts): TeleporterAPI`
Creates a new teleporter instance.

```lua
local teleporter = TeleporterClass.new(deps, {
    teleportPlaceId = 123456789,
    model = workspace.Teleporters.MainTeleporter,
    countdown = 30,
    teleporterType = "Public",
    minPlayers = 2,
    maxPlayers = 16
})
```

**Parameters:**
- `deps: Deps` - Dependency injection container (Services, SharedPackages, etc.)
- `opts: Opts` - Configuration options (see Configuration Options table)

**Returns:** `TeleporterAPI` - The teleporter instance

---

#### Public Methods

##### `Init(): void`
Initializes the teleporter, sets up connections and GUI.

```lua
teleporter:Init()
```

**Must be called after creation** to activate the teleporter.

---

##### `UpdateText(message?, countdown?): void`
Updates the GUI text labels.

```lua
-- Update message only
teleporter:UpdateText("Waiting for players...", nil)

-- Update countdown only
teleporter:UpdateText(nil, 15)

-- Update both
teleporter:UpdateText("Starting soon!", 5)
```

**Parameters:**
- `message: string?` - Text to display in the message label
- `countdown: number?` - Countdown value to display (shows "Xs")

---

##### `Destroy(): void`
Cleans up the teleporter instance.

```lua
teleporter:Destroy()
```

Disconnects all events, cancels timers, and clears the queue.

---

### TeleporterService

The service automatically manages all teleporters in the workspace.

#### Lifecycle Methods

##### `Init(deps): void`
Initializes the service with dependencies.

```lua
TeleporterService:Init(deps)
```

Called automatically by the service registry.

---

##### `Start(): void`
Starts the service and creates all teleporters.

```lua
TeleporterService:Start()
```

Scans `workspace.Teleporters` and creates teleporter instances based on model names.

---

##### `Destroy(): void`
Cleans up the service.

```lua
TeleporterService:Destroy()
```

## Queue System

### Joining the Queue

Players automatically join a queue when they touch the teleporter's `Trigger` part.

**Requirements to join:**
- Player must have a living character
- Player cannot already be in another teleporter queue
- Teleporter must not be locked (party reservation)
- Teleporter must not be on cooldown
- For friends-only parties, player must be friends with party leader

**On joining:**
1. Player is teleported to spawn location
2. Character is moved to teleporter area
3. Leave queue GUI appears
4. Death detection is enabled
5. Queue count updates on GUI

### Leaving the Queue

Players can leave via:
1. **Manual leave**: Click "Leave Queue" button in GUI
2. **Character death**: Automatically removed
3. **Player disconnect**: Automatically cleaned up

**On leaving:**
1. Player removed from queue
2. Leave queue GUI destroyed
3. Character teleported away from teleporter
4. Queue count updates

### Global Queue Management

The system prevents players from being in multiple queues simultaneously:

```lua
-- Internal tracking
_playerToTeleporter[player] = teleporter

-- Validation before joining
if _playerToTeleporter[player] then
    return -- Player already in a queue
end
```

## Party System

### Party Creation Flow

1. **First player touches trigger**
   - Teleporter locks
   - Player becomes party leader
   - Reserve party GUI appears
   - 10-second timeout starts

2. **Party leader configures party**
   - Selects party size (2-8 players)
   - Toggles friends-only mode
   - Confirms or cancels

3. **Party is created**
   - Timeout cancelled
   - Reserve GUI removed
   - Leave queue GUI appears
   - Teleporter unlocks
   - Other players can join

4. **Party fills up**
   - Countdown starts when minPlayers reached
   - Teleports when full or countdown ends

### Party Reservation Timeout

If party leader doesn't configure within 10 seconds:

```lua
function Teleporter:_startPartyReservationTimeout(player)
    self._partyReservationThread = task.spawn(function()
        task.wait(10)
        
        -- Remove player from queue
        self:_removePlayerFromQueue(player)
        
        -- Reset party state
        self._partyLeader = nil
        self._isLocked = false
        self:UpdateText("Waiting for players...", nil)
    end)
end
```

### Friends-Only Mode

When enabled, validates friendship before allowing players to join:

```lua
-- Check friendship via Roblox API
local success, isFriend = pcall(function()
    return player:IsFriendsWith(self._partyLeader.UserId)
end)

if not success or not isFriend then
    -- Show error message to player
    Messages:ShowMessage(player, "This party is friends-only!", "Error")
    return
end
```

## Countdown System

### Starting Countdown

Countdown starts when:
- **Public**: `minPlayers` is reached
- **Party**: `minPlayers` is reached AND party size is set

```lua
function Teleporter:_startCountdown()
    self._countdownThread = task.spawn(function()
        local timeRemaining = self._opts.countdown or 30

        while timeRemaining > 0 do
            -- Check if still enough players
            local minPlayers = self._opts.minPlayers or 1
            if #self._queue < minPlayers then
                self:_cancelCountdown()
                return
            end
            
            -- Update GUI
            self:UpdateText(nil, timeRemaining)
            
            task.wait(1)
            timeRemaining -= 1
        end

        self:_teleportPlayers()
    end)
end
```

### Cancelling Countdown

Countdown cancels when:
- Queue drops below `minPlayers`
- All players leave queue
- Teleporter is destroyed

### Instant Teleport

When `instantTeleportOnFull = true`, teleports immediately when reaching max capacity:

```lua
if self._opts.instantTeleportOnFull and #self._queue >= maxCapacity then
    self:_cancelCountdown()
    self:_teleportPlayers()
end
```

## Teleportation Process

### Reserved Server Creation

Each teleport creates a reserved server:

```lua
function Teleporter:_teleportPlayers()
    local playersToTeleport = table.clone(self._queue)
    
    -- Reserve a private server
    local reserveSuccess, reserveResult = pcall(function()
        return TeleportService:ReserveServer(placeId)
    end)
    
    local reservedServerAccessCode = reserveResult
    
    -- Create TeleportOptions
    local teleportOptions = Instance.new("TeleportOptions")
    teleportOptions.ReservedServerAccessCode = reservedServerAccessCode
    
    -- Teleport players
    local success, result = pcall(function()
        return TeleportService:TeleportAsync(
            placeId, 
            playersToTeleport, 
            teleportOptions
        )
    end)
end
```

### Teleport Cooldown

3-second cooldown prevents repeated teleport attempts:

```lua
function Teleporter:_startCooldown()
    self._isOnCooldown = true
    self._cooldownThread = task.spawn(function()
        task.wait(3)
        self._isOnCooldown = false
        self._cooldownThread = nil
    end)
end
```

### Failure Handling

If teleport fails:
1. Error is caught and logged
2. Players remain in lobby
3. Leave queue GUIs are restored
4. Queue is cleared
5. Cooldown activates to prevent spam
6. Status resets to "Waiting for players..."

### Success Handling

If teleport succeeds:
1. Players are removed from queue
2. Leave queue GUIs are removed
3. Fade-to-black effect is shown
4. Global registry is cleaned up
5. Queue clears
6. Cooldown activates

## GUI System

### BillboardGui (Status Display)

Shows queue status and countdown above the teleporter.

**Auto-generated structure:**
```lua
BillboardGui (TeleportGui)
├── Message (TextLabel)      -- "Players: 3/8"
└── Countdown (TextLabel)    -- "15s"
```

**Default properties:**
- Size: `UDim2.new(6, 0, 3, 0)`
- StudsOffset: `Vector3.new(0, 3, 0)`
- AlwaysOnTop: `true`

### Leave Queue GUI (ScreenGui)

Appears when player joins queue (except party leader during reservation).

**Required in:** `ReplicatedStorage.Shared.Assets.UI.LeaveTeleportQueueGui`

**Features:**
- Button to leave queue
- Fires "LeaveTeleportQueue" RemoteEvent
- Automatically removed on teleport/death

### Reserve Party GUI (ScreenGui)

Appears for party leader to configure party.

**Required in:** `ReplicatedStorage.Shared.Assets.UI.ReserveTeleportPartyGui`

**Attributes:**
- `MinPartySize: number` - Minimum selectable party size
- `MaxPartySize: number` - Maximum selectable party size

**Features:**
- Party size selector (2-8 players)
- Friends-only toggle checkbox
- Create button (fires "CreateTeleportParty" RemoteEvent)
- Cancel button (fires "CancelTeleportPartyReservation" RemoteEvent)
- 10-second timeout indicator

### Teleport Fade GUI (Auto-generated)

Fade-to-black effect during teleportation.

**Auto-generated structure:**
```lua
ScreenGui (TeleportFadeGui)
└── FadeFrame (Frame)
    -- Black frame covering entire screen
    -- Animates from transparent to opaque
```

## Remote Events

### LeaveTeleportQueue

**Client → Server**

Allows player to manually leave the teleporter queue.

```lua
-- Client-side (in GUI button)
local remote = ReplicatedStorage.Shared.Packages.Remotes
    :GetRemote("RemoteEvent", "LeaveTeleportQueue")
remote:FireServer()

-- Server-side (handled automatically)
_leaveQueueRemote.OnServerEvent:Connect(function(player)
    local teleporter = _playerToTeleporter[player]
    if teleporter then
        teleporter:_onPlayerLeaveQueue(player)
    end
end)
```

---

### CreateTeleportParty

**Client → Server**

Creates a party with specified size and friends-only setting.

```lua
-- Client-side (in Reserve Party GUI)
local remote = ReplicatedStorage.Shared.Packages.Remotes
    :GetRemote("RemoteEvent", "CreateTeleportParty")
remote:FireServer(partySize, isFriendsOnly)

-- Server-side (handled automatically)
_createTeleportPartyRemote.OnServerEvent:Connect(function(player, partySize, isFriendsOnly)
    local teleporter = _playerToTeleporter[player]
    if teleporter then
        teleporter:_onCreateTeleportParty(player, partySize, isFriendsOnly)
    end
end)
```

**Parameters:**
- `partySize: number` - Size of party (2-8)
- `isFriendsOnly: boolean` - Friends-only restriction

---

### CancelTeleportPartyReservation

**Client → Server**

Cancels party reservation and removes player from queue.

```lua
-- Client-side (in Reserve Party GUI cancel button)
local remote = ReplicatedStorage.Shared.Packages.Remotes
    :GetRemote("RemoteEvent", "CancelTeleportPartyReservation")
remote:FireServer()

-- Server-side (handled automatically)
_cancelTeleportPartyReservationRemote.OnServerEvent:Connect(function(player)
    local teleporter = _playerToTeleporter[player]
    if teleporter then
        teleporter:_onCancelTeleportPartyReservation(player)
    end
end)
```

## Common Patterns

### Basic Public Teleporter

```lua
-- In TeleporterService:Start()
local mainTeleporter = TeleporterClass.new(_deps, {
    teleportPlaceId = 123456789,
    model = workspace.Teleporters.MainTeleporter,
    countdown = 30,
    teleporterType = "Public",
    minPlayers = 4,
    maxPlayers = 16
})
mainTeleporter:Init()
```

### Small Party Teleporter

```lua
local duoTeleporter = TeleporterClass.new(_deps, {
    teleportPlaceId = 123456789,
    model = workspace.Teleporters.DuoTeleporter,
    countdown = 10,
    teleporterType = "Party",
    minPlayers = 2,
    maxPlayers = 2  -- Exactly 2 players
})
duoTeleporter:Init()
```

### Instant Teleporter

```lua
local instantTeleporter = TeleporterClass.new(_deps, {
    teleportPlaceId = 123456789,
    model = workspace.Teleporters.InstantTeleporter,
    countdown = 0,  -- No countdown
    teleporterType = "Public",
    minPlayers = 1,
    maxPlayers = 1,
    instantTeleportOnFull = true
})
instantTeleporter:Init()
```

### Large Raid Teleporter

```lua
local raidTeleporter = TeleporterClass.new(_deps, {
    teleportPlaceId = 123456789,
    model = workspace.Teleporters.RaidTeleporter,
    countdown = 60,  -- Longer countdown for large groups
    teleporterType = "Public",
    minPlayers = 10,
    maxPlayers = 50,
    instantTeleportOnFull = false  -- Wait for countdown even when full
})
raidTeleporter:Init()
```

## Validation & Error Handling

### Model Validation

On creation, teleporter validates:

```lua
function Teleporter:_validateModel(): boolean
    -- Check for Trigger part
    local trigger = self._model:FindFirstChild("Trigger")
    if not trigger or not trigger:IsA("BasePart") then
        warn(`Model {self._model:GetFullName()} has no Trigger part`)
        return false
    end
    
    -- Get spawn location (optional)
    local playerSpawn = self._model:FindFirstChild("PlayerSpawn")
    if playerSpawn and playerSpawn:IsA("BasePart") then
        self._spawnCFrame = playerSpawn.CFrame
    else
        self._spawnCFrame = self._model:GetPivot()
    end
    
    -- Auto-create GUI if missing
    local gui = self._model:FindFirstChild("TeleportGui")
    if not gui then
        self._gui = self:_createPlaceholderGui(trigger)
    end
    
    return true
end
```

### Join Validation

Before adding player to queue:

1. ✓ Player has character
2. ✓ Character is alive
3. ✓ Not already in THIS queue
4. ✓ Not in ANY other queue
5. ✓ Teleporter not locked (party reservation)
6. ✓ Teleporter not on cooldown
7. ✓ Queue not full
8. ✓ Friends check (if friends-only party)

### Teleport Error Handling

```lua
local success, result = pcall(function()
    return TeleportService:TeleportAsync(placeId, players, options)
end)

if not success then
    warn(`[Teleporter] Teleport failed: {result}`)
    
    -- Restore player GUIs
    for _, player in playersToTeleport do
        if player.Parent then
            self:_createLeaveQueueGui(player)
        end
    end
    
    -- Clear queue and reset
    table.clear(self._queue)
    self:UpdateText("Waiting for players...", nil)
end
```

## Performance Considerations

- **Queue checks**: O(n) linear search, acceptable for small queues (<50 players)
- **Global registry**: O(1) lookup via dictionary for cross-teleporter validation
- **Countdown threads**: One thread per teleporter, lightweight task.spawn
- **GUI updates**: Only updates when queue changes, not per-frame
- **Touch events**: Single connection per teleporter, immediate return for invalid touches
- **Cleanup**: Automatic via player disconnect/death events

## Troubleshooting

### Players can't join teleporter
1. Check `Trigger` part exists and is named correctly
2. Verify `CanCollide = false` and `Transparency = 1` on trigger
3. Ensure player's character has Humanoid with Health > 0
4. Check teleporter isn't locked (party reservation)
5. Verify teleporter isn't on cooldown

### Countdown not starting
1. Check queue size >= `minPlayers`
2. For party teleporters, verify party size is set
3. Ensure countdown isn't already running
4. Check for error messages in output

### Teleport fails with error
1. Verify `teleportPlaceId` is correct
2. Ensure place is published and accessible
3. Check TeleportService API is enabled in game settings
4. Verify players still exist when teleporting
5. Check Roblox service status

### GUI not appearing
1. Check `LeaveTeleportQueueGui` exists in ReplicatedStorage.Shared.Assets.UI
2. Verify player has PlayerGui
3. Check for existing GUI with same name (auto-removed)
4. Ensure ResetOnSpawn = false on GUI

### Party reservation stuck
1. Check 10-second timeout is working
2. Verify `ReserveTeleportPartyGui` exists in Assets.UI
3. Ensure RemoteEvents are connected
4. Check party leader hasn't left

### Friends-only not working
1. Verify `:IsFriendsWith()` API is accessible
2. Check error messages in pcall
3. Ensure party leader UserId is valid
4. Test with actual friends on platform

## Migration Guide

### From Legacy Teleporter System

1. **Update model structure**
   - Rename touch part to `Trigger`
   - Add optional `PlayerSpawn` part
   - Create `TeleportGui` BillboardGui with Message/Countdown labels

2. **Create UI assets**
   - Design `LeaveTeleportQueueGui` with button
   - Design `ReserveTeleportPartyGui` with controls
   - Set MinPartySize/MaxPartySize attributes

3. **Configure TeleporterService**
   - Add teleporter creation in `Start()`
   - Set appropriate min/max players
   - Choose Public vs Party type

4. **Test thoroughly**
   - Test public teleporter flow
   - Test party creation and friends-only
   - Test edge cases (disconnects, deaths)

### Adding New Teleporter

1. Create model in `workspace.Teleporters`
2. Add `Trigger` part (BasePart)
3. Add optional `PlayerSpawn` and `TeleportGui`
4. Add creation code in `TeleporterService:Start()`
5. Configure options (place ID, type, limits)
6. Call `Init()` on instance

## Example: Complete Setup

```lua
-- In TeleporterService.luau
function TeleporterService:Start()
    if not self._inited or self._started then return end
    self._started = true

    local teleportersFolder = workspace:WaitForChild("Teleporters")
    local teleporterObjects = {}
    
    -- Main public teleporter
    local mainTeleporter = TeleporterClass.new(_deps, {
        teleportPlaceId = 124240592130904,
        model = teleportersFolder.MainTeleporter,
        countdown = 25,
        teleporterType = "Public",
        minPlayers = 2,
        maxPlayers = 25,
        instantTeleportOnFull = true
    })
    mainTeleporter:Init()
    table.insert(teleporterObjects, mainTeleporter)
    
    -- Party teleporter
    local partyTeleporter = TeleporterClass.new(_deps, {
        teleportPlaceId = 124240592130904,
        model = teleportersFolder.PartyTeleporter,
        countdown = 10,
        teleporterType = "Party",
        minPlayers = 2,
        maxPlayers = 8,
        instantTeleportOnFull = true
    })
    partyTeleporter:Init()
    table.insert(teleporterObjects, partyTeleporter)
    
    -- Solo teleporter
    local soloTeleporter = TeleporterClass.new(_deps, {
        teleportPlaceId = 124240592130904,
        model = teleportersFolder.SoloTeleporter,
        countdown = 5,
        teleporterType = "Public",
        minPlayers = 1,
        maxPlayers = 1,
        instantTeleportOnFull = true
    })
    soloTeleporter:Init()
    table.insert(teleporterObjects, soloTeleporter)
end
```

## Security Considerations

- **Server validation**: All queue operations validated server-side
- **Remote event checks**: Verify player is in correct teleporter before processing
- **Friends validation**: Uses Roblox API `:IsFriendsWith()` 
- **Party leader verification**: Only party leader can configure party
- **Cooldown protection**: Prevents teleport spam/abuse
- **Queue isolation**: Players can't be in multiple queues simultaneously
- **Reserved servers**: Each group gets isolated server instance

## License

This system is part of the woolly project framework.
